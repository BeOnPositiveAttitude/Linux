Установить iptables на Ubuntu: `sudo apt install iptables`.

Смотреть правила iptables: `iptables -L`.

```bash
Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
```

- Chain INPUT - входящий трафик, например чтобы разрешить входящие ssh-подключения, нужно создать здесь правило
- Chain OUTPUT - исходящий трафик, подключения инициированные хостом к другим системам
- Chain FORWARD - обычно используется маршрутизаторами, когда данные перенаправляются другим устройствам в сети

Политика по умолчанию ACCEPT разрешает любой входящий и исходящий трафик.

Каждая цепочка (chain) имеет несколько правил внутри. Chain of rules.

Каждое правило осуществляет проверку и принимает или отбрасывает пакет, основываясь на условии.

<img src="screen1.png" width="600" height="150"><br>

То есть, если пакет удовлетворяет условию, тогда он будет либо принят либо отброшен, в зависимости от правила.

Если же пакет не удовлетворяет условию, тогда он будет передан на проверку следующему правилу в цепочке.

Также мы можем настраивать правила таким образом, чтобы в качестве условия рассматривался destination трафика.

Добавим правило на хост devapp01, разрешающее входящее ssh-подключение с клиентской машины:

`iptables -A INPUT -p tcp -s 172.16.238.187 --dport 22 -j ACCEPT`, где

- `-A` - Add Rule
- `-p` - Protocol
- `-s` - Source
- `-d` - Destination
- `--dport` - Destination Port
- `-j` - Action to take

Что теперь произойдет, если другой клиент попытается подключиться по ssh к хосту devapp01? Т.к. у нас нет отдельного правила для этого случая, то подключение попытается пройти через дефолтную политику, которая принимает все входящие подключения.

Мы же хотим, чтобы только определенные клиенты могли подключаться по ssh к нашему хосту. Поэтому нам нужно создать другое INPUT-правило:

`iptables -A INPUT -p tcp --dport 22 -j DROP`.

Последовательность, в которой добавляются правила очень важна, т.к. они выполняются сверху вниз. То есть применяется первое правило из списка, которое удовлетворяет заданному условия, все остальные игнорируются.

Добавим оставшиеся правила на хост devapp01. Нужно разрешить исходящие подключения к серверу БД devdb01 по порту 5432, к репозиторию caleston-repo-01 по порту 80? запретить исходящий трафик в интернет по портам 80/443, разрешить входяший трафик по порту 80 от клиента caleston-lp10.

```bash
iptables -A OUTPUT -p tcp -d 172.16.238.11 --dport 5432 -j ACCEPT   #к БД
iptables -A OUTPUT -p tcp -d 172.16.238.15 --dport 80 -j ACCEPT     #к repo
iptables -A OUTPUT -p tcp --dport 80 -j DROP                        #запрет до интернета
iptables -A OUTPUT -p tcp --dport 443 -j DROP                       #запрет до интернета
iptables -A INPUT -p tcp -s 172.16.238.187 --dport 80 -j ACCEPT     #от клиента
```

Предположим теперь нам нужно разрешить исходящие подключения к сайту `caleston-hq.com`.

Если мы добавим его через опцию `-A`, тогда оно будет помещено "на дно" цепочки, и вышестоящие правила, запрещающие весь исходящий в интернет трафик, будут иметь над ним более высокий приоритет и ничего не сработает. Поэтому нужно использовать опцию `-I`, которая добавит правило на вершину цепочки:

`iptables -I OUTPUT -p tcp -d 172.16.238.100 --dport 443 -j ACCEPT`.